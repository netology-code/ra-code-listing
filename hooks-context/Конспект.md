# Конспект по теме «Hooks и Context API»

## Зачем нужны хуки

Раньше в React для работы со **состоянием** и **жизненным циклом** приходилось использовать классовые компоненты. Хуки позволяют делать то же самое в **функциональных** компонентах.
Основные преимущества:

* меньше кода и вложенности;
* можно переиспользовать логику через кастомные хуки;
* легче разделять бизнес-логику и UI.

---

## useState — локальное состояние

Хранит данные внутри компонента. Возвращает массив `[значение, функция для обновления]`.
Каждый вызов функции обновления вызывает новый рендер.

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Счётчик: {count}
    </button>
  );
}
```

---

## useEffect — побочные эффекты

Используется для действий, которые не связаны напрямую с рендером: запросы к серверу, таймеры, подписки.
Массив зависимостей управляет частотой запуска.

```jsx
import { useEffect } from 'react';

useEffect(() => {
  const id = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(id); // очистка при размонтировании
}, []); // [] → запуск один раз при монтировании
```

---

## Пример: поллинг новостей

Запрос данных каждые 5 секунд. Простая версия:

```jsx
import { useEffect, useState } from 'react';

export default function LatestNews() {
  const [news, setNews] = useState([]);

  useEffect(() => {
    const id = setInterval(async () => {
      const res = await fetch(import.meta.env.VITE_NEWS_URL);
      const data = await res.json();
      setNews(data);
    }, 5000);

    return () => clearInterval(id);
  }, []);

  return <ul>{news.map(n => <li key={n.id}>{n.content}</li>)}</ul>;
}
```

---

## useRef — хранение значения без рендера

Хранит «живое» значение между рендерами. Обновление `.current` не вызывает перерисовку.

Пример: защита от устаревших запросов.

```jsx
import { useEffect, useRef, useState } from 'react';

export default function LatestNewsStable() {
  const [news, setNews] = useState([]);
  const tsRef = useRef();

  useEffect(() => {
    const id = setInterval(async () => {
      const ts = Date.now();
      tsRef.current = ts;

      const res = await fetch(import.meta.env.VITE_NEWS_URL);
      const data = await res.json();

      if (tsRef.current === ts) setNews(data); // обновляем только актуальные данные
    }, 5000);

    return () => clearInterval(id);
  }, []);

  return <ul>{news.map(n => <li key={n.id}>{n.content}</li>)}</ul>;
}
```

---

## Кастомные хуки — пример usePolling

Чтобы не дублировать один и тот же код, можно вынести его в функцию.

```jsx
import { useEffect, useRef, useState } from 'react';

export default function usePolling(url, interval = 5000, initial = []) {
  const [data, setData] = useState(initial);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const tsRef = useRef();

  useEffect(() => {
    let canceled = false;

    const fetchData = async () => {
      const ts = Date.now();
      tsRef.current = ts;
      setLoading(true);
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(res.statusText);
        const next = await res.json();
        if (!canceled && tsRef.current === ts) {
          setData(next);
          setError(null);
        }
      } catch (e) {
        if (!canceled) setError(e);
      } finally {
        if (!canceled) setLoading(false);
      }
    };

    fetchData();
    const id = setInterval(fetchData, interval);

    return () => { canceled = true; clearInterval(id); };
  }, [url, interval]);

  return { data, loading, error };
}
```

---

## Дополнительные хуки

### useReducer — управление состоянием через редьюсер

Альтернатива `useState`. Все изменения описываются в одной функции `reducer`.

```jsx
import { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'inc': return { count: state.count + 1 };
    case 'dec': return { count: state.count - 1 };
    default:    return state;
  }
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <button onClick={() => dispatch({ type: 'dec' })}>-</button>
      {state.count}
      <button onClick={() => dispatch({ type: 'inc' })}>+</button>
    </div>
  );
}
```

---

### useCallback — запоминает функцию

Помогает не создавать новую функцию на каждый рендер.

```jsx
import { useState, useCallback } from 'react';

function SearchBox({ onSearch }) {
  const [q, setQ] = useState('');
  const handleChange = useCallback((e) => {
    setQ(e.target.value);
    onSearch(e.target.value);
  }, [onSearch]);

  return <input value={q} onChange={handleChange} />;
}
```

---

### useMemo — запоминает вычисления

Полезно для тяжёлых фильтраций или сортировок.

```jsx
import { useMemo, useState } from 'react';

function ExpensiveList({ items }) {
  const [q, setQ] = useState('');

  const filtered = useMemo(() => {
    return items.filter(i => i.toLowerCase().includes(q.toLowerCase()));
  }, [items, q]);

  return (
    <>
      <input value={q} onChange={e => setQ(e.target.value)} />
      <ul>{filtered.map((i, idx) => <li key={idx}>{i}</li>)}</ul>
    </>
  );
}
```

---

### useTransition — разделение обновлений

Срочные обновления (например, печать текста) выполняются сразу, несрочные (например, фильтрация) откладываются.

```jsx
import { useState, useTransition } from 'react';

function Search({ items }) {
  const [q, setQ] = useState('');
  const [list, setList] = useState(items);
  const [isPending, startTransition] = useTransition();

  function onChange(e) {
    const value = e.target.value;
    setQ(value);
    startTransition(() => {
      setList(items.filter(i => i.includes(value)));
    });
  }

  return (
    <>
      <input value={q} onChange={onChange} />
      {isPending && <p>Фильтрация…</p>}
      <ul>{list.map((i, idx) => <li key={idx}>{i}</li>)}</ul>
    </>
  );
}
```

---

### useDeferredValue — отложенное значение

Используется для ввода текста, чтобы отрисовка больших списков не мешала вводу.

```jsx
import { useDeferredValue, useState } from 'react';

function SearchDeferred({ items }) {
  const [q, setQ] = useState('');
  const deferredQ = useDeferredValue(q);

  const filtered = items.filter(i => i.includes(deferredQ));

  return (
    <>
      <input value={q} onChange={e => setQ(e.target.value)} />
      <ul>{filtered.map((i, idx) => <li key={idx}>{i}</li>)}</ul>
    </>
  );
}
```

---

### useId — уникальные id

Удобно для связки `label` и `input`.

```jsx
import { useId } from 'react';

function Field() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Имя</label>
      <input id={id} />
    </>
  );
}
```

---

### useLayoutEffect — синхронный эффект

Срабатывает **после изменения DOM, но до отрисовки на экране**.
Используется для измерений и синхронных корректировок.

```jsx
import { useLayoutEffect, useRef, useState } from 'react';

function Box() {
  const ref = useRef(null);
  const [height, setHeight] = useState(0);

  useLayoutEffect(() => {
    if (ref.current) {
      const rect = ref.current.getBoundingClientRect();
      setHeight(rect.height);
    }
  }, []);

  return (
    <>
      <div ref={ref} style={{ padding: 20, background: '#eee' }}>
        Контент блока
      </div>
      <p>Высота блока: {height}px</p>
    </>
  );
}
```

---

## Context API

Иногда нужно передать данные (например, токен пользователя) во всё дерево компонентов.
Передача через props становится неудобной. **Context API** позволяет создать общий источник данных.

---

### Создание контекста

```jsx
// contexts/AuthContext.js
import { createContext } from 'react';

const AuthContext = createContext({
  token: null,
  setToken: () => {},
});

export default AuthContext;
```

---

### Provider — делимся состоянием

```jsx
// App.jsx
import { useState } from 'react';
import AuthContext from './contexts/AuthContext';

export default function App() {
  const [token, setToken] = useState(null);

  return (
    <AuthContext.Provider value={{ token, setToken }}>
      {/* всё дерево имеет доступ к token */}
    </AuthContext.Provider>
  );
}
```

---

### useContext — доступ к данным

```jsx
// components/ComponentA.jsx
import { useContext } from 'react';
import AuthContext from '../contexts/AuthContext';

export default function ComponentA() {
  const { token, setToken } = useContext(AuthContext);

  return (
    <div>
      <pre>token: {JSON.stringify(token)}</pre>
      <button onClick={() => setToken(`new-${Math.random()}`)}>
        Сменить токен
      </button>
    </div>
  );
}
```

---

### Consumer — альтернатива

```jsx
// components/ComponentC.jsx
import AuthContext from '../contexts/AuthContext';

export default function ComponentC() {
  return (
    <AuthContext.Consumer>
      {({ token, setToken }) => (
        <div>
          <pre>{JSON.stringify(token)}</pre>
          <button onClick={() => setToken(`new-${Math.random()}`)}>
            Сменить токен
          </button>
        </div>
      )}
    </AuthContext.Consumer>
  );
}
```

---

## Итоги

* `useState`, `useEffect`, `useRef` — базовые хуки для состояния и эффектов.
* Кастомные хуки помогают переиспользовать код.
* `useReducer`, `useCallback`, `useMemo` — для сложной логики и оптимизаций.
* `useTransition`, `useDeferredValue` — для плавности интерфейса.
* `useId` и `useLayoutEffect` — для работы с формами и DOM.
* Context API решает проблему «проброса пропсов» и делает общие данные доступными в любом месте дерева.

