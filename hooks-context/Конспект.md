# Конспект по теме «Hooks и Context API»

## Зачем нужны хуки

Раньше в React для работы с **состоянием** и **жизненным циклом** приходилось использовать классовые компоненты. Хуки позволяют делать то же самое в **функциональных** компонентах.  

Основные преимущества использования хуков:

* меньше кода и вложенности;
* можно переиспользовать логику через кастомные хуки;
* легче разделять бизнес-логику и UI.

## useState — локальное состояние

Хранит данные внутри компонента. Возвращает массив `[значение, функция для обновления]`.  
Каждый вызов функции обновления вызывает новый рендер.

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Счётчик: {count}
    </button>
  );
}
````

### Разбор синтаксиса

1. `import { useState } from 'react'` — подключаем хук.
2. `const [count, setCount] = useState(0)` — деструктурируем массив:

   * `count` — текущее значение;
   * `setCount` — функция для обновления;
   * `0` — начальное значение.
3. При вызове `setCount(...)` компонент автоматически перерисовывается.

---

## useEffect — побочные эффекты

Используется для действий, которые не связаны напрямую с рендером: запросы к серверу, таймеры, подписки.
Массив зависимостей управляет частотой запуска.

```jsx
import { useEffect } from 'react';

useEffect(() => {
  const id = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(id); // очистка при размонтировании
}, []); // [] → запуск один раз при монтировании
```

### Разбор синтаксиса

1. `useEffect(callback, deps)` — принимает функцию и массив зависимостей.
2. Внутри `callback` можно запускать побочные эффекты (запросы, таймеры).
3. Если `callback` возвращает функцию, она вызовется при размонтировании или изменении зависимостей.
4. `[]` означает «выполнить один раз при монтировании».

---

## Пример: поллинг новостей

Запрос данных каждые 5 секунд.

```jsx
import { useEffect, useState } from 'react';

export default function LatestNews() {
  const [news, setNews] = useState([]);

  useEffect(() => {
    const id = setInterval(async () => {
      const res = await fetch(import.meta.env.VITE_NEWS_URL);
      const data = await res.json();
      setNews(data);
    }, 5000);

    return () => clearInterval(id);
  }, []);

  return <ul>{news.map(n => <li key={n.id}>{n.content}</li>)}</ul>;
}
```

### Разбор синтаксиса

1. `useState([])` — состояние для новостей.
2. В `useEffect` создаём `setInterval`, который каждые 5 секунд делает запрос.
3. `return () => clearInterval(id)` — очистка интервала при размонтировании.
4. `news.map(...)` — отображение списка.

---

## useRef — хранение значения без рендера

Хранит «живое» значение между рендерами. Обновление `.current` не вызывает перерисовку.   
Пример: защита от устаревших запросов.

```jsx
import { useEffect, useRef, useState } from 'react';

export default function LatestNewsStable() {
  const [news, setNews] = useState([]);
  const tsRef = useRef();

  useEffect(() => {
    const id = setInterval(async () => {
      const ts = Date.now();
      tsRef.current = ts;

      const res = await fetch(import.meta.env.VITE_NEWS_URL);
      const data = await res.json();

      if (tsRef.current === ts) setNews(data); // обновляем только актуальные данные
    }, 5000);

    return () => clearInterval(id);
  }, []);

  return <ul>{news.map(n => <li key={n.id}>{n.content}</li>)}</ul>;
}
```

### Разбор синтаксиса

1. `useRef()` создаёт объект `{ current: undefined }`.
2. Значение `tsRef.current` сохраняется между рендерами, но не вызывает обновление UI.
3. Сравнение `if (tsRef.current === ts)` защищает от «устаревшего» ответа.

---

## Кастомные хуки — пример usePolling

Чтобы не дублировать один и тот же код, можно вынести его в функцию.

```jsx
import { useEffect, useRef, useState } from 'react';

export default function usePolling(url, interval = 5000, initial = []) {
  const [data, setData] = useState(initial);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const tsRef = useRef();

  useEffect(() => {
    let canceled = false;

    const fetchData = async () => {
      const ts = Date.now();
      tsRef.current = ts;
      setLoading(true);
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(res.statusText);
        const next = await res.json();
        if (!canceled && tsRef.current === ts) {
          setData(next);
          setError(null);
        }
      } catch (e) {
        if (!canceled) setError(e);
      } finally {
        if (!canceled) setLoading(false);
      }
    };

    fetchData();
    const id = setInterval(fetchData, interval);

    return () => { canceled = true; clearInterval(id); };
  }, [url, interval]);

  return { data, loading, error };
}
```

### Разбор синтаксиса

1. Кастомный хук — это обычная функция, которая использует встроенные хуки.
2. `useState` хранит `data`, `loading`, `error`.
3. `useEffect` запускает периодический запрос и очищает таймер.
4. Возвращаем объект `{ data, loading, error }`, что позволяет переиспользовать хук в любых компонентах.

---

## Дополнительные хуки

### useReducer — управление состоянием через редьюсер

Альтернатива `useState`. Все изменения описываются в одной функции `reducer`.

```jsx
import { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'inc': return { count: state.count + 1 };
    case 'dec': return { count: state.count - 1 };
    default:    return state;
  }
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <div>
      <button onClick={() => dispatch({ type: 'dec' })}>-</button>
      {state.count}
      <button onClick={() => dispatch({ type: 'inc' })}>+</button>
    </div>
  );
}
```

### Разбор синтаксиса

1. `useReducer(reducer, initialState)` возвращает `[state, dispatch]`.
2. `dispatch({ type: '...' })` отправляет событие.
3. `reducer(state, action)` описывает все изменения состояния.

---

### useCallback — запоминает функцию

Помогает не создавать новую функцию на каждый рендер.

```jsx
import { useState, useCallback } from 'react';

function SearchBox({ onSearch }) {
  const [q, setQ] = useState('');
  const handleChange = useCallback((e) => {
    setQ(e.target.value);
    onSearch(e.target.value);
  }, [onSearch]);

  return <input value={q} onChange={handleChange} />;
}
```

### Разбор синтаксиса

1. `useCallback(fn, deps)` возвращает мемоизированную версию функции.
2. Функция пересоздаётся только при изменении зависимостей.

---

### useMemo — запоминает вычисления

Полезно для тяжёлых фильтраций или сортировок.

```jsx
import { useMemo, useState } from 'react';

function ExpensiveList({ items }) {
  const [q, setQ] = useState('');

  const filtered = useMemo(() => {
    return items.filter(i => i.toLowerCase().includes(q.toLowerCase()));
  }, [items, q]);

  return (
    <>
      <input value={q} onChange={e => setQ(e.target.value)} />
      <ul>{filtered.map((i, idx) => <li key={idx}>{i}</li>)}</ul>
    </>
  );
}
```

### Разбор синтаксиса

1. `useMemo(calcFn, deps)` возвращает результат вычисления.
2. Пересчёт происходит только при изменении зависимостей.

---

### useTransition — разделение обновлений

Срочные обновления (например, печать текста) выполняются сразу, несрочные (например, фильтрация) откладываются.

```jsx
import { useState, useTransition } from 'react';

function Search({ items }) {
  const [q, setQ] = useState('');
  const [list, setList] = useState(items);
  const [isPending, startTransition] = useTransition();

  function onChange(e) {
    const value = e.target.value;
    setQ(value);
    startTransition(() => {
      setList(items.filter(i => i.includes(value)));
    });
  }

  return (
    <>
      <input value={q} onChange={onChange} />
      {isPending && <p>Фильтрация…</p>}
      <ul>{list.map((i, idx) => <li key={idx}>{i}</li>)}</ul>
    </>
  );
}
```

### Разбор синтаксиса

1. `useTransition()` возвращает `[isPending, startTransition]`.
2. Всё внутри `startTransition(...)` считается «несрочным» обновлением.
3. `isPending` показывает, идёт ли выполнение.

---

### useDeferredValue — отложенное значение

Используется для ввода текста, чтобы отрисовка больших списков не мешала вводу.

```jsx
import { useDeferredValue, useState } from 'react';

function SearchDeferred({ items }) {
  const [q, setQ] = useState('');
  const deferredQ = useDeferredValue(q);

  const filtered = items.filter(i => i.includes(deferredQ));

  return (
    <>
      <input value={q} onChange={e => setQ(e.target.value)} />
      <ul>{filtered.map((i, idx) => <li key={idx}>{i}</li>)}</ul>
    </>
  );
}
```

### Разбор синтаксиса

1. `useDeferredValue(value)` возвращает «отложенную» версию значения.
2. Полезно для плавности при вводе текста и фильтрации.

---

### useId — уникальные id

Удобно для связки `label` и `input`.

```jsx
import { useId } from 'react';

function Field() {
  const id = useId();
  return (
    <>
      <label htmlFor={id}>Имя</label>
      <input id={id} />
    </>
  );
}
```

### Разбор синтаксиса

1. `useId()` возвращает уникальный id.
2. Значение этого id затем используется в `htmlFor` у `label` и в `id` у `input` для их связи.

---

### useLayoutEffect — синхронный эффект

Срабатывает **после изменения DOM, но до отрисовки на экране**.
Используется для измерений и синхронных корректировок.

```jsx
import { useLayoutEffect, useRef, useState } from 'react';

function Box() {
  const ref = useRef(null);
  const [height, setHeight] = useState(0);

  useLayoutEffect(() => {
    if (ref.current) {
      const rect = ref.current.getBoundingClientRect();
      setHeight(rect.height);
    }
  }, []);

  return (
    <>
      <div ref={ref} style={{ padding: 20, background: '#eee' }}>
        Контент блока
      </div>
      <p>Высота блока: {height}px</p>
    </>
  );
}
```

### Разбор синтаксиса

1. `useLayoutEffect` работает как `useEffect`, но выполняется синхронно перед отрисовкой.
2. Используется для измерений DOM.

---

## Context API

Иногда нужно передать данные (например, токен пользователя) во всё дерево компонентов.
Передача через props становится неудобной. **Context API** позволяет создать общий источник данных.

---

### Создание контекста

```jsx
// contexts/AuthContext.js
import { createContext } from 'react';

const AuthContext = createContext({
  token: null,
  setToken: () => {},
});

export default AuthContext;
```

### Разбор синтаксиса

1. `createContext(defaultValue)` создаёт объект контекста.
2. `defaultValue` используется только если нет `<Provider>`.

---

### Provider — делимся состоянием

```jsx
// App.jsx
import { useState } from 'react';
import AuthContext from './contexts/AuthContext';

export default function App() {
  const [token, setToken] = useState(null);

  return (
    <AuthContext.Provider value={{ token, setToken }}>
      {/* всё дерево имеет доступ к token */}
    </AuthContext.Provider>
  );
}
```

### Разбор синтаксиса

1. `<AuthContext.Provider value={...}>` делает данные доступными для всех дочерних компонентов.
2. `value` может содержать любое значение: примитив, объект, функции.

---

### useContext — доступ к данным

```jsx
// components/ComponentA.jsx
import { useContext } from 'react';
import AuthContext from '../contexts/AuthContext';

export default function ComponentA() {
  const { token, setToken } = useContext(AuthContext);

  return (
    <div>
      <pre>token: {JSON.stringify(token)}</pre>
      <button onClick={() => setToken(`new-${Math.random()}`)}>
        Сменить токен
      </button>
    </div>
  );
}
```

### Разбор синтаксиса

1. `useContext(AuthContext)` возвращает текущее значение контекста.
2. Использование `useContext` избегает «проброса пропсов» вниз по дереву.

---

### Consumer — альтернатива

```jsx
// components/ComponentC.jsx
import AuthContext from '../contexts/AuthContext';

export default function ComponentC() {
  return (
    <AuthContext.Consumer>
      {({ token, setToken }) => (
        <div>
          <pre>{JSON.stringify(token)}</pre>
          <button onClick={() => setToken(`new-${Math.random()}`)}>
            Сменить токен
          </button>
        </div>
      )}
    </AuthContext.Consumer>
  );
}
```

### Разбор синтаксиса

1. `<AuthContext.Consumer>` принимает функцию-ребёнка.
2. Аргумент функции — текущее значение контекста.
3. Менее удобен, чем `useContext`, но работает и в классовых компонентах.

---

## Итоги

* `useState`, `useEffect`, `useRef` — базовые хуки для состояния и эффектов.
* Кастомные хуки помогают переиспользовать код.
* `useReducer`, `useCallback`, `useMemo` — для сложной логики и оптимизаций.
* `useTransition`, `useDeferredValue` — для плавности интерфейса.
* `useId` и `useLayoutEffect` — для работы с формами и DOM.
* Context API решает проблему «проброса пропсов» и делает общие данные доступными в любом месте дерева.

---

## Шпаргалка: хуки и Context API

* **useState** — `const [state, setState] = useState(initial)`
  Хранение локального состояния, пара «значение + функция обновления».

* **useEffect** — `useEffect(() => { ... }, [deps])`
  Побочные эффекты (запросы, таймеры, подписки), очистка через `return`.

* **useRef** — `const ref = useRef(initial)`
  Объект `{ current }`, сохраняется между рендерами, не вызывает перерисовку.

* **useReducer** — `const [state, dispatch] = useReducer(reducer, init)`
  Управление состоянием через редьюсер и `dispatch(action)`.

* **useCallback** — `const fn = useCallback(() => {...}, [deps])`
  Возвращает мемоизированную функцию, пересоздаётся только при изменении зависимостей.

* **useMemo** — `const value = useMemo(() => calc(), [deps])`
  Мемоизация вычислений, полезно для тяжёлых операций.

* **useTransition** — `const [isPending, startTransition] = useTransition()`
  Разделяет срочные и несрочные обновления.

* **useDeferredValue** — `const deferred = useDeferredValue(value)`
  Отложенная версия значения, сглаживает ввод/отрисовку.

* **useId** — `const id = useId()`
  Стабильный уникальный id для связки `label` и `input`.

* **useLayoutEffect** — `useLayoutEffect(() => {...}, [deps])`
  Синхронный эффект: выполняется после изменения DOM, но до отрисовки.

* **createContext** — `const Ctx = createContext(defaultValue)`
  Создаёт объект контекста.

* **Provider** — `<Ctx.Provider value={...}>` Обеспечивает доступ к значению контекста для всех дочерних компонентов.
