# Конспект занятия: События и состояние (React)

---

## План занятия

- События
- Состояние
- Фильтрация и отображение списков

---

## Задача

Освоить работу с событиями и состоянием в React:
- Научиться правильно назначать обработчики событий в JSX
- Понять, как устроен SyntheticEvent и зачем он нужен
- Освоить useState для управления состоянием в функциональных компонентах
- Познакомиться с работой state в классовых компонентах
- Научиться фильтровать списки с использованием состояния и событий

---

## Обработка событий в React

В нативном JS обработчики событий добавляют так:
```js
// Способ 1 — addEventListener
document.querySelector('button').addEventListener('click', () => {
  console.log('clicked');
});

// Способ 2 — свойство onclick
document.querySelector('button').onclick = functionRef;

// Способ 3 — inline-атрибут в HTML
<button onclick="functionRef()">Отправить</button>
```

В React используется похожий подход, но в нём есть важные отличия:
1. Имена событий пишутся в стиле **camelCase** (`onClick`, `onChange`, `onSubmit`).
2. В JSX передаём **ссылку на функцию**, а не строку.
3. React использует **SyntheticEvent** для единообразного поведения во всех браузерах.

---

## Пример 1: LikeButton — обработка клика

```jsx
function LikeButton() {
  const handleClick = (evt) => {
    console.log('Like clicked', evt);
  };

  return <button onClick={handleClick}>Like</button>;
}
```

### Разбор по шагам
1. Создаём функцию-обработчик `handleClick`, принимающую объект события `evt`.
2. Передаём её в атрибут `onClick` без вызова (без скобок).
3. При клике React вызовет `handleClick`, передав `SyntheticEvent`.

**Что важно запомнить:**
- Если написать `onClick={handleClick()}`, функция выполнится сразу при рендере.
- Всегда передавайте ссылку на функцию, а не результат её вызова.

### Передача параметров в обработчик
```jsx
<button onClick={(evt) => handleClick(evt, id)}>Click</button>
```
Или:
```jsx
const handleWithId = (id) => (evt) => { ... };
<button onClick={handleWithId(id)}>Click</button>
```

---

## SyntheticEvent и отмена поведения

SyntheticEvent — кроссбраузерная обёртка, которая имеет методы `preventDefault()` и `stopPropagation()`.

```jsx
function FormButton() {
  const handleClick = (event) => {
    event.preventDefault();
    event.stopPropagation();
    console.log('Форма отправлена!');
  };

  return <button onClick={handleClick}>Отправить</button>;
}
```

### Разбор по шагам
1. `event.preventDefault()` отменяет действие по умолчанию (например, отправку формы).
2. `event.stopPropagation()` предотвращает всплытие события.
3. Логируем сообщение в консоль.

---

## useState

`useState` — хук для хранения состояния в функциональных компонентах.
```js
const [state, setState] = useState(initialValue);
```
- `state` — текущее значение.
- `setState` — функция для обновления.
- `initialValue` — значение начального состояния.
- При вызове `setState` компонент перерисуется.

**Правила:**
- Хуки вызываем только на верхнем уровне функции-компонента.
- Нельзя вызывать внутри условий или циклов.
- Изменять состояние напрямую запрещено — для этого всегда используйте функцию `setState`.

---

## Пример 3: Counter — счётчик на useState

```jsx
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>Счёт: {count}</p>
      <button onClick={() => setCount(count - 1)}>-</button>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

### Разбор по шагам
1. Инициализируем состояние `count` со значением `0`.
2. Создаём кнопки для уменьшения и увеличения.
3. Каждое нажатие вызывает `setCount` с новым значением.

**Что важно запомнить:**
- Для обновления на основе предыдущего значения используйте форму:
  ```jsx
  setCount(prev => prev + 1);
  ```
- Это исключает ошибки при асинхронных обновлениях.

---

## Пример 4: state в классовых компонентах

```jsx
import React, { Component } from 'react';

class ClassLikeButton extends Component {
  state = { clicks: 0 };

  render() {
    return (
      <button onClick={() => this.setState({ clicks: this.state.clicks + 1 })}>
        Clicked: {this.state.clicks}
      </button>
    );
  }
}
```

### Разбор по шагам
1. Инициализируем `this.state` как объект с ключом `clicks`.
2. При клике вызываем `this.setState`, передавая новый объект состояния.
3. React вызывает `render` заново и обновляет DOM.

**Что важно запомнить:**
- Нельзя изменять `this.state` напрямую (`this.state.clicks++` — ошибка).
- setState может быть асинхронным, используйте форму с функцией при зависимости от предыдущего значения.

---

## Пример 5: Фильтрация списка по вводу

```jsx
const products = ['яблоко', 'банан', 'груша', 'апельсин'];

function ProductList() {
  const [query, setQuery] = useState('');

  const filtered = products.filter(item =>
    item.toLowerCase().includes(query.toLowerCase())
  );

  return (
    <div>
      <input
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Поиск..."
      />
      <ul>
        {filtered.map((item, i) => <li key={i}>{item}</li>)}
      </ul>
    </div>
  );
}
```

### Разбор по шагам
1. `products` — исходный массив.
2. `query` — состояние для строки поиска.
3. `filtered` — результат фильтрации через `filter` и `includes`.
4. В `input` значение связано с `query` и обновляется через `onChange`.

**Что важно запомнить:**
- Controlled components позволяют синхронизировать UI и состояние.
- Для ключей в списках лучше использовать уникальные id, а не индекс.

---

## Итоги

- События в React имеют единый API (SyntheticEvent) и одинаково работают во всех браузерах.
- Обработчики передаются как функции, а не строки.
- useState — основной способ управления состоянием в функциональных компонентах.
- В классовых компонентах состояние хранится в `this.state` и обновляется через `this.setState`.
- Фильтрация и другие операции над данными выполняются на основе состояния.

